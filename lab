
1) Write the Python code and Execute the program to find 
gradient of following scalar functions. 
i) ğ’™ğŸğ’šğ’› .
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]**2*v[1]*v[2]
G=gradient(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given scalar function F = ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Gradient of F=")
display(G)

ii) ğŸ‘ğ’™ğŸğ’šz
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=3*v[0]**2*v[1]*v[2]
G=gradient(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given scalar function F = ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Gradient of F=")
display(G)

 iii) x2y3z4
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]**2*v[1]**3*v[2]**4
G=gradient(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given scalar function F = ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Gradient of F=")
display(G)

2)Write Python code and Execute the program to 
find divergence of following vector functions.
 i) ğ…âƒ— = ğ±ğŸğ²ğ¢Ì‚+ ğ²ğ³ğŸğ£Ì‚+ ğ±ğŸğ³ğ¤Ì‚
 
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]**2*v[1]*v.x+v[1]*v[2]**2*v.y+v[0]**2*v[2]*v.z
G=divergence(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector point function is ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Divergence of F=")
display(G)

ii)ğ‘­âƒ—âƒ— = ğŸğ’™ğŸğ’›ğ’ŠÌ‚âˆ’ ğ’™ğ’šğŸğ’›ğ’‹Ì‚+ ğŸ‘ğ’šğ’›ğŸğ’ŒÌ‚
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=2*v[0]**2*v[2]*v.x-v[0]*v[1]**2*v[2]*v.y+3*v[1]*v[2]**2*v.z
G=divergence(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector point function is ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Divergence of F=")
display(G)

iii) ğ‘­âƒ—âƒ— = xyziÌ‚+ 3ğ‘¥2ğ‘¦jÌ‚+ (xğ‘§2 âˆ’ ğ‘¦2ğ‘§)kÌ‚
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]*v[1]*v[2]*v.x+3*v[0]**2*v[1]*v.y+(v[0]*v[2]**2-v[1]**2*v[2])*v.z
G=divergence(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector point function is ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Divergence of F=")
display(G)

3) Write the Python code and Execute program to find curl of given 
vector point function.
i)ğŸğ¢Ì‚+ ğŸğ±ğŸğ²ğ³ ğ£Ì‚âˆ’ ğŸ‘ğ²ğ³ğŸ ğ¤Ì‚
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]*v[1]**2*v.x+2*v[0]**2*v[1]*v[2]*v.y-3*v[1]*v[2]**2*v.z
G=curl(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector point function is ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Curl of F=")
display(G)

ii) ğ‘­âƒ—âƒ— = ğ’™ğŸğ’šğ’› ğ’ŠÌ‚+ ğŸğ’™ğ’šğŸğ’› ğ’‹Ì‚+ ğ’™ğ’šğ’›ğŸ ğ’ŒÌ‚
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=v[0]**2*v[1]*v[2]*v.x+2*v[0]*v[1]**2*v[2]*v.y+v[0]*v[1]*v[2]**2*v.z
G=curl(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector point function is ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Curl of F=")
display(G)

iii ) ğ…âƒ— = ğŸğ±ğŸğ³ ğ¢Ì‚âˆ’ ğ±ğ²ğŸğ³ ğ£Ì‚+ ğŸ‘ğ²ğ³ğŸ ğ¤Ì‚
from sympy.physics.vector import *
from sympy import var
var('x,y,z')
v=ReferenceFrame('v')
F=2*v[0]**2*v[2]*v.x-v[0]*v[1]**2*v[2]*v.y+3*v[1]*v[2]**2*v.z
G=curl(F,v)
F=F.subs([(v[0],x), (v[1],y), (v[2],z)])
print("Given vector function F = ")
display(F)
G=G.subs([(v[0],x), (v[1],y), (v[2],z)])
print("\n Curl of F=")
display(G)

4) a) Using Greenâ€™s theorem, Evaluate âˆ® [(ğ’™ + ğŸğ’š) ğ’…ğ’™ + (ğ’™ âˆ’ ğŸğ’š)ğ’…ğ’š]
ğ’„ where C is the region bounded by coordinate axes and the line x=1 and y=1. 
from sympy import *
var('x,y')
p=x + 2*y
q=x - 2*y
f=diff(q,x)-diff(p,y)
soln=integrate(f,[x,0,1],[y,0,1])
print("I=",soln)

b) Using Greenâ€™s theorem, Evaluate âˆ® [(ğ’™ğ’š + ğ’šğŸ) ğ’…ğ’™ + (ğ’™ğŸ)ğ’…ğ’š]ğ’„where C is the closed curve bounded by y=x and y=x2 .
from sympy import *
var('x,y')
p=x*y + y**2
q=x**2
f=diff(q,x)-diff(p,y)
soln=integrate(f,[y,x**2,x],[x,0,1])
print("I=",soln)

c)Using Greenâ€™s theorem, Evaluate âˆ® [(ğŸ‘ğ’™ + ğŸ’ğ’š) ğ’…ğ’™ + (ğŸğ’™ âˆ’ ğŸ‘ğ’š)ğ’…ğ’š]ğ’„ where C is the boundary of the circle x2 + y2 = 4
from sympy import *
var('x,y')
p=3*x+4*y
q=2*x-3*y
f=diff(q,x)-diff(p,y)
soln=integrate(f,[y,-sqrt(4-x**2),sqrt(4-x**2)],[x,-2,2])
print("I=",soln)

5) a) Write the Python code and Execute the program for Finding a real root of 
the equation ğ’™ğŸ‘â€“ 5x - 7=0 by using Regula - Falsi method correct to three decimal places.
from numpy import*
a=0
b=6
p=6
n=7
h=(b-a)/p
x=linspace(a,b,n)
f=(1/(1+x)**2)
for i in range (0,n):
    print(round(x[i],ndigits=4))
    print(round(f[i],ndigits=4))
    TR=round((h/2)*(f[0]+f[n-1]+2*sum(f[1:n-1])),ndigits=4)
    S13=round((h/3)*(f[0]+f[n-1]+2*sum(f[2:n-1:2])+4*sum(f[1:n-1:2])),ndigits=4)
    S38=round(((h*3/8)*(f[0]+f[n-1]+2*sum(f[3:n-2:3])+3*sum(f[1:n:3]+f[2:n-1:3]))),ndigits=4)
print('the requried integral by trapiziodal rule is',TR)
print("the requried integral by simpsons third rule is",S13)
print("the requried integral by simpsons three by eightÂ ruleÂ is",S38)

6 ) Write the Python code and Execute the program for Finding y from the 
following data at x=5 by using Newton Forward Interpolation formula.
X 4 6 8 10
Y 1 3 8 16
from numpy import*
n=int(input(â€œEnter number of datapoints:â€))
x=zeros((n))
y=zeros((n,n))
print(â€œEnter data for x and y:â€)
for i in range(n):
x[i]=float(input(â€˜x[â€˜+str(i)+â€™]=â€™))
y[i][0]= float(input(â€˜y[â€˜+str(i)+â€™]=â€™))
for i in range (1,n):
for j in range(0,n-i):
y[j][i] = y[j+1][i-1] â€“ y[j][i-1]
print(â€œ\n FORWARD DIFFERENCE TABLE\nâ€);
for i in range (0,n):
print(â€˜%0.2fâ€™ %(x[i]), end=â€™â€™)
for j in range(0,n-i):
print(â€˜\t\t%0.2fâ€™ %(y[i][ j ]), end=â€™â€™)
print()
#Newtonâ€™s Forward Interpolation Formula
V=float(input(â€œEnter the value to be interpolated: â€œ))
def u_cal(u,n):
temp=u;
for i in range(1,n):
temp=temp*(u â€“ i);
return temp;
def fact(n):
f=1;
for i in range(2,n+1):
f*=i
return f;
sum=y[0][0];
u=(v-x[0])/(x[1]-x[0]);
for i in range(1,n):
sum=sum+( u_cal(u,i)*y[0][i])/fact(i);
print(â€œ\n Interpolated value at â€œ, v,â€isâ€, round(sum, 6));

7 ) Write the Python code and Execute the program for Finding y from the 
following data at x=2.65 by using Newton Backward Interpolation formula.
X -1 0 1 2 3
Y -21 6 15 12 3
from numpy import*
n=int(input(â€œEnter number of data points:â€))
x=zeros((n))
y=zeros((n,n))
print(â€œEnter data for x and y:â€)
for i in range(n):
x[i]=float(input(â€˜x[â€˜+str(i)+â€™]=â€™))
y[i][0]= float(input(â€˜y[â€˜+str(i)+â€™]=â€™))
for i in range (1,n):
for j in range(n-1,i-1,-1):
y[j][i] = y[j][i-1] â€“ y[j-1][i-1]
print(â€œ\n BACKWARD DIFFERENCE TABLE\nâ€);
for i in range (0,n):
print(â€˜%0.2fâ€™ %(x[i]), end=â€™â€™)
for j in range(0,i+1):
print(â€˜\t\t%0.2fâ€™ %(y[i][ j ]), end=â€™â€™)
print()
#Newtonâ€™s Backward Interpolation Formula
V=float(input(â€œEnter the value to be interpolated: â€œ))
def u_cal(u,n):
temp=u;
for i in range(1,n):
temp=temp*(u + i);
return temp;
def fact(n):
f=1;
for i in range(2,n+1):
f *=i
return f
sum=y[n-1][0]
u=(v-x[n-1])/(x[1]-x[0]);
for i in range(1,n):
sum=sum+( u_cal(u,i)*y[n-1][i])/fact(i);
print(â€œ\n Interpolated value at â€œ, v,â€isâ€, round(sum, 6)); 

8 ) a)Write Python code and Execute the program to evaluate âˆ« âˆšğŸ + ğ’™ğŸ‘ğŸğŸdx using 
i)Simpsonâ€™s 1/3 rd ii)Trapezoidal rule iii)Simpsonâ€™s 3/8 rule 
from numpy import *
a=0
b=1
p=6
n=7
h=(b-a)/p
x=linspace(a,b,n)
f=sqrt(1+x**3)
for i in range(0,n):
 print(round(f[i],ndigits=4))
TR=round((h/2)*(f[0]+2*sum(f[1:n-1])+f[n-1]),ndigits=4)
S13=round((h/3)*((f[0]+f[n-1])+4*sum(f[1:n-1:2]) +2*sum(f[2:n-1:2])), 
ndigits=4)
S38=round((3*h/8)*((f[0]+f[n-1])+2*sum(f[3:n-2:3]) 
+3*sum(f[1:n:3]+(f[2:n-1:3]))),ndigits=4)
print("The required integral by Trapezoidal Rule is",TR)
print("The required integral by Simpsonâ€™s 1/3 Rule is",S13)
print("The required integral by Simpsonâ€™s 3/8 Rule is :",S38)

8) b)Write the Python code and Execute the program to evaluate âˆ«ğ’…ğ’™ğŸ+ğ’™ğŸğŸğŸusing i)Simpsonâ€™s 1/3 rd rule ii)Trapezoidal Rule iii)Simpsonâ€™s 3/8 rule 
from numpy import *
a=0
b=1
p=6
n=7
h=(b-a)/p
x=linspace(a,b,n)
f=(1/(1+x**2))
for i in range(0,n):
 print(round(f[i],ndigits=4))
TR=round((h/2)*(f[0]+2*sum(f[1:n-1])+f[n-1]),ndigits=4)
S13=round((h/3)*((f[0]+f[n-1])+4*sum(f[1:n-1:2]) +2*sum(f[2:n-1:2])), ndigits=4)
S38=round((3*h/8)*((f[0]+f[n-1])+2*sum(f[3:n-2:3]) +3*sum(f[1:n:3]+(f[2:n-1:3]))), 
ndigits=4)
print("The required integral by Trapezoidal Rule is",TR)
print("The required integral by Simpsonâ€™s 1/3 Rule is",S13)
print("The required integral by Simpsonâ€™s 3/8 Rule is :",S38) 

8) c) Write the Python code and Execute the program to evaluate âˆ«ğ’…ğ’™(ğŸ+ğ’™)ğŸğŸusing 
i)Simpsonâ€™s 1/3 rd rule ii)Trapezoidal Rule iii)Simpsonâ€™s 3/8 rule 
from numpy import*
a=0
b=6
p=6
n=7
h=(b-a)/p
x=linspace(a,b,n)
f=(1/(1+x)**2)
for i in range(0,n):
 print(round(f[i],ndigits=4))
TR=round((h/2)*(f[0]+2*sum(f[1:n-1])+f[n-1]),ndigits=4)
S13=round((h/3)*((f[0]+f[n-1])+4*sum(f[1:n-1:2]) +2*sum(f[2:n-1:2])), ndigits=4)
S38=round((3*h/8)*((f[0]+f[n-1])+2*sum(f[3:n-2:3]) +3*sum(f[1:n:3]+(f[2:n-1:3]))),
ndigits=4)
print("The required integral by Trapezoidal Rule is",TR)
print("The required integral by Simpsonâ€™s 1/3 Rule is",S13)
print("The required integral by Simpsonâ€™s 3/8 Rule is :",S38)

8) d)Write the Python code and Execute the program to evaluate âˆ«ğ’…ğ’™(ğŸ+ğ’™)ğŸğŸusing 
i)Simpsonâ€™s 1/3 rd rule ii)Trapezoidal Rule iii)Simpsonâ€™s 3/8 rule 
from numpy import*
a=0
b=1
p=6
n=7
h=(b-a)/p
x=linspace(a,b,n)
f=(1/(1+x))
for i in range(0,n):
 print(round(f[i],ndigits=4))
TR=round((h/2)*(f[0]+2*sum(f[1:n-1])+f[n-1]),ndigits=4)
S13=round((h/3)*((f[0]+f[n-1])+4*sum(f[1:n-1:2]) +2*sum(f[2:n-1:2])),ndigits=4)
S38=round((3*h/8)*((f[0]+f[n-1])+2*sum(f[3:n-2:3]) +3*sum(f[1:n:3]+(f[2:n-1:3]))), 
ndigits=4)
print("The required integral by Trapezoidal Rule is",TR)
print("The required integral by Simpsonâ€™s 1/3 Rule is",S13)
print("The required integral by Simpsonâ€™s 3/8 Rule is :",S38)

8) e) Apply the Runge Kutta method to find the solution of dy/dx = 1 + (y/x) at 
y(2) taking h = 0.2. Given that y(1) = 2.
from sympy import *
import numpy as np
def RungeKutta (g,x0 ,h,y0 ,xn):
 x,y= symbols ('x,y')
 f=lambdify([x,y],g)
 xt=x0+h
 Y=[y0]
 while xt<=xn:
 k1=h*f(x0 ,y0)
 k2=h*f(x0+h/2, y0+k1/2)
 k3=h*f(x0+h/2, y0+k2/2)
 k4=h*f(x0+h, y0+k3)
 y1=y0+(1/6)*(k1+2*k2+2*k3+k4)
 Y. append (y1)
 x0=xt
 y0=y1
 xt=xt+h
 return np. round (Y,2)
RungeKutta ('1+(y/x)',1 ,0.2, 2,2)

9) a) Write the Python code and Execute :: (4 D2 - 4D -3)y =e2x
from sympy import *
x=symbols('x')
y=Function('y')(x)
DE=Eq(4*Derivative(y,x,2) - 4*Derivative(y,x) -3*y , exp(2*x))
GS=dsolve(DE)
display(GS)

9) b) Write the Python code and Execute :: ğ’…ğŸğ’šğ’…ğ‘¥2â€“ 2 ğ‘‘ğ‘¦ğ‘‘ğ‘¥+ y =cos3x
from sympy import * 
x=symbols('x')
y=Function('y')(x)
DE=Eq(Derivative(y,x,2) - 2*Derivative(y,x) +y, cos(3*x))
GS=dsolve(DE)
display(GS)

9) c) Write the Python code and Execute :: ğ’…ğŸğ’šğ’…ğ‘¥2 + ğ’š = ğ’”ğ’Šğ’ğŸğ’™
from sympy import *
x=symbols('x')
y=Function('y')(x)
DE=Eq(Derivative(y,x,2)+y, sin (2*x))
GS=dsolve(DE)
display(GS)

9) d) Write the Python code and Execute :: ğ’…ğŸğ’šğ’…ğ‘¥2- 2 ğ‘‘ğ‘¦ğ‘‘ğ‘¥+ 3ğ’š = cosğŸğ’™
 from sympy import * 
x=symbols('x') 
y=Function('y')(x)
DE=Eq(Derivative(y,x,2)-2*Derivative(y,x)+3*y, cos(2*x)) 
GS=dsolve(DE)
display(GS)

10) a) Solve the PDE, xp + yq = z, where z = f(x, y)
from sympy . solvers .pde import pdsolve
from sympy import Function , Eq ,cot , classify_pde , pprint
from sympy .abc import x, y, a
f = Function ('f')
z = f(x, y)
zx = z.diff (x)
zy = z.diff (y)
# Solve xp+yq=z
eq = Eq(x*zx+y*zy , z)
pprint (eq)
print ("\n")
soln = pdsolve (eq ,z)
pprint( soln )

10) b) Solve the PDE, x2p + y2 q = (x + y)z, where p = ğğ’›ğğ’™ and q = ğğ’›ğğ’š
from sympy . solvers .pde import pdsolve
from sympy import Function , Eq ,cot , classify_pde , pprint
from sympy .abc import x, y, a
f = Function ('f')
z = f(x, y)
zx = z. diff (x)
zy = z. diff (y)
# Solve x^2p+y^2q =(x+y)z
eq=Eq(x ** 2*zx+y ** 2*zy ,(x+y)*z)
pprint (eq)
print ("\n")
soln = pdsolve (eq ,z)
pprint ( soln )
